///////////////////////////////////////////////////////////////////////////////////////////////
//
//  Implementation of the BLX (van den Berg - Lin - Xi) / QTM (Queue Transmission Model)
//  model of queue and platoon dynamics in a traffic network.
//
//  Authors: Ayal Taitler (ataitler@gmail.com)
//           Ilia Smirnov (iliathesmirnov@gmail.com)
//
//  References:
//      S. Lin, B. De Schutter, Y. Xi, and J. Hellendoorn, "A simplified macroscopic urban
//      traffic network model for model-based predictive control," Proceedings of the 12th
//      IFAC Symposium on Transportation Systems, Redondo Beach, California, pp. 286â€“
//      291, Sept. 2009
//
//      Guilliard, I., Sanner, S., Trevizan, F. W., & Williams, B. C. "Nonhomogeneous
//      time mixed integer linear programming formulation for traffic signal control,"
//      Transportation Research Record, pp. 128-138 2595(1), 2016
//
///////////////////////////////////////////////////////////////////////////////////////////////

domain BLX_model {

    requirements = {
        constrained-state,
        integer-valued
    };

    types {
        intersection : object;
        phase : object;
        time : object;
    };

    pvariables {
        ///////////////////////////////////////////
        // non-fluents == topology and geometry
        ///////////////////////////////////////////

        // simulation time step in seconds
        Ts                                                     :  { non-fluent, int, default = 1 };
        // average vehicle length in meters
        Lv                                                     :  { non-fluent, real, default = 5 };

        // each intersection is assigned a unique index
        INTERSECTION-INDEX(intersection)                       :  { non-fluent, int, default = 0 };

        // cartesian coordinates of the intersection
        X(intersection)                                        :  { non-fluent, real, default = 0 };
        Y(intersection)                                        :  { non-fluent, real, default = 0 };


        // link between (uplink intersection, downlink intersection)
        LINK(intersection, intersection)                       :  { non-fluent, bool, default = false };

        // number of lanes in link
        Nl(intersection, intersection)                         : { non-fluent, int, default = 1 };

        // free-flow velocity of traffic in link in m/s
        V(intersection, intersection)                          :  { non-fluent, real, default = 13.8 };

        // saturation flow rate leaving turn (u,d,o)
        MU(intersection, intersection, intersection)           :  { non-fluent, real, default = 1.2 };

        // fraction of the traffic turning to link (d,o) from link (u,d)
        BETA(intersection, intersection, intersection)         :  { non-fluent, real, default = 0.33 };


        // is intersection a source?
        SOURCE(intersection)                                   :  { non-fluent, bool, default = false };

        // is intersection a sink?
        SINK(intersection)                                     :  { non-fluent, bool, default = false };

        // is intersection signalized?
        TL(intersection)                                       :  { non-fluent, bool, default = false };

        // arrival rate at sources - the variance for a uniform distribution
        ARRIVAL-RATE(intersection)                             :  { non-fluent, real, default = 0.67 };

        // max. flow per lane - cap when releasing virtual queue and vehicles at sinks
        MAX-FLOWRATE(intersection)                             :  { non-fluent, real, default = 0.67 };


        // phases should be enumerated between 0 and (num.phases-1) in every intersection
        PHASE-INDEX(phase)                                     :  { non-fluent, int, default = 0 };

        // phase constraints and properties
        PHASE-MIN(phase)                                       :  { non-fluent, int, default = 6 };
        PHASE-MAX(phase)                                       :  { non-fluent, int, default = 60 };
        PHASE-ALL-RED-DUR(phase)                               :  { non-fluent, int, default = 3 };

        // is the phase is part of the control plan of the traffic light?
        PHASE-OF(phase, intersection)                          :  { non-fluent, bool, default = false};

        // is turn green in phase?
        GREEN(intersection, intersection, intersection, phase) :  { non-fluent, bool, default = false };

        // phase transition permitted?
        VALID-CHANGE(phase, phase)                             :  { non-fluent, bool, default = false };


        // time ordering for time-delayed queues
        NEXT(time, time)                                       :  { non-fluent, bool, default = false };

        // is the time index first in the queue, i,e., no delay
        TIME-HEAD(time)                                        :  {non-fluent, bool, default = false };

        // is the time index last in the queue, i,e., maximum delay memory depth
        TIME-TAIL(time)                                        :  {non-fluent, bool, default = false };

        // time object to actual time delay index
        TIME-VAL(time)                                         :  { non-fluent, int, default = 1 };



        //////////////////////////////
        // interm fluents
        //////////////////////////////

        // distance between intersections
        Dl(intersection, intersection)                         :  { interm-fluent, real };

        // link capacity (maximal storage)
        Cl(intersection, intersection)                         :  { interm-fluent, real };

        // is the triple (u,d,o) a turn?
        TURN(intersection, intersection, intersection)         :  { interm-fluent, bool };

        // time delay variables
        tau(intersection, intersection)                        :  { interm-fluent, int };
        gamma(intersection, intersection)                      :  { interm-fluent, real };

        // number of cars arriving at the end of the queue (u,d)
        Ma(intersection, intersection)                         :  { interm-fluent, real };

        // arrivals at time step k in link (u,d) is u is a source
        arrivals(intersection)                                 :  { interm-fluent, real };

        // flow from source u into the network
        src-flow(intersection)                                 :  { interm-fluent, real };

        // overflow from source u
        src-overflow(intersection)                             :  { interm-fluent, real };

        //outflow at turn (u,d,o)
        turn-outflow(intersection, intersection, intersection) :  { interm-fluent, real };

        // is green for inflows from link (u,d) in the direction of link (d,o)?
        b(intersection, intersection, intersection)            :  { interm-fluent, bool };



        //////////////////////////////
        // states fluents
        //////////////////////////////
        // number of cars leaving link (u,d) and turning towards link (d,o) - state because of the time delay "memory"
        Ml(intersection, intersection, intersection, time) :  { state-fluent, real, default = 0 };

        // number of cars leaving source u toward intersection d - state because of the time delay "memory"
        Mlsrc(intersection, intersection, time)            :  { state-fluent, real, default = 0 };

        // queue length at step in link (u,d) turning in direction (d,o)
        q(intersection, intersection, intersection)        :  { state-fluent, real, default = 0 };

        // total queue length at step in link (u,d) (all directions)
        qd(intersection, intersection)                     :  { state-fluent, real, default = 0 };

        //virtual queue at source (u) (i.e. vehicles held outside of the network)
        virtual-q(intersection)                            :  { state-fluent, real, default = 0 };

        // number of vehicles in link
        Nc(intersection, intersection)                     :  { state-fluent, real, default = 0 };

        // current phase index
        cur-ph-idx(intersection)                           :  { state-fluent, int, default = 0 };

        // current phase time
        cur-ph-t(intersection)                             :  { state-fluent, int, default = 0 };

        // is current phase-time less than or equal to phase min time?
        // state to use in action constraints
        cur-ph-before-min(intersection)                 :  { state-fluent, bool, default = false };

        // is current phase-time at phase max time?
        cur-ph-at-max(intersection)                        :  { state-fluent, bool, default = false };

        // remaining time in interphase (all-red phase)
        all-red(intersection)                              :  { state-fluent, int, default = 0 };


        //////////////////////////////
        // action fluents
        //////////////////////////////
        // set the phase 
        // The default value of -1 corresponds to not setting
        // any phase, and is used for SINKS and SOURCES.
        // For TLs, there should be an action each time-step.
        //    * If the action is equal to cur-ph-idx, the current phase is extended
        //    * If the action is NOT equal to cur-ph-idx, the phase is changed

        set-phase(intersection)                            :  { action-fluent, int, default = -1 };


        //////////////////////////////
        // observation fluents
        //////////////////////////////
        // only the queues that are relevant (no time delay queues, and no total of vehicle number)

    };

    cpfs {

        ////////////////////////////////////
        // interm fluents
        ////////////////////////////////////

        // distance between intersections
        Dl(?u,?d) = sqrt[ (X(?u)-X(?d))*(X(?u)-X(?d)) + (Y(?u)-Y(?d))*(Y(?u)-Y(?d)) ];

        // derived fluent for the actual capacity
        Cl(?u,?d) = Dl(?u,?d) * Nl(?u,?d) / Lv;

        // is the triple (u,d,o) a turn?
        // the third term rules out U-turns
        TURN(?u,?d,?o) = LINK(?u,?d) ^ LINK(?d,?o) ^ (~(INTERSECTION-INDEX(?u) == INTERSECTION-INDEX(?o)));

        // time-delay variables update
        tau(?u,?d) = LINK(?u,?d) * floor[ (Cl(?u,?d) - qd(?u,?d))*Lv / (Nl(?u,?d)*V(?u,?d)*Ts) ];
        gamma(?u,?d) = LINK(?u,?d) * ((Cl(?u,?d) - qd(?u,?d))*Lv / (Nl(?u,?d)*V(?u,?d)*Ts) - tau(?u,?d));

        // green for inflows from link (u,d) in the direction of link (d,o)
        // for non-signalized intersections, all turns are considereed to be permitted
        b(?u,?d,?o) = ~TL(?d)
                      | [( sum_{?p : phase}[ PHASE-OF(?p,?d) * (PHASE-INDEX(?p)==cur-ph-idx(?d)) * GREEN(?u,?d,?o,?p)] ) == 1];

        // how many cars should arrive for the direction of u on the link (u,d) if u is a source
        arrivals(?u) =  SOURCE(?u) * Uniform(0,2*ARRIVAL-RATE(?u)*Ts);

        // flows from source u
        src-flow(?u) = SOURCE(?u) * max[0, min[ arrivals(?u), (sum_{?d : intersection}[ LINK(?u,?d) * (Cl(?u,?d)-Nc(?u,?d)) ]) ]];
        src-overflow(?u) = SOURCE(?u) * max[0, arrivals(?u) - src-flow(?u)];

        // number of vehicles arriving to tail of queue at link (u,d)
        // add time-delayed outflows from the sources, and time-delayed outflows over all incoming turns
        Ma(?u,?d) = LINK(?u,?d) * (     SOURCE(?u)  * (sum_{?t : time}[TIME-HEAD(?t) * Mlsrc(?u,?d,?t)])
                                   + (1-SOURCE(?u)) * (sum_{?t : time}[TIME-HEAD(?t) * (sum_{?i : intersection}[Ml(?i,?u,?d,?t)])]) );

        // outflow at turn (u,d,o)
        // min(undersaturated, saturated, oversaturated)
        turn-outflow(?u,?d,?o) = TURN(?u,?d,?o)
                                 * b(?u,?d,?o)
                                 * max[0, min[ q(?u,?d,?o) + Ma(?u,?d)*BETA(?u,?d,?o), // Undersaturated flow
                                          min[ BETA(?u,?d,?o)*MU(?u,?d,?o)*Ts,         // Saturated flow
                                               Cl(?d,?o)-Nc(?d,?o) ]]];                // Oversaturated flow (Capacity-Count=Storage)

             

        ////////////////////////////////////
        // State space evolution
        ////////////////////////////////////

        // Source outflows and virtual queues
        Mlsrc'(?u,?d,?t) = LINK(?u,?d) * (
              (TIME-VAL(?t) == tau(?u,?d))     * (1-gamma(?u,?d)) * src-flow(?u)
            + (TIME-VAL(?t) == (tau(?u,?d)+1)) * gamma(?u,?d) * src-flow(?u)
            + (sum_{?t2 : time}[ NEXT(?t,?t2) * Mlsrc(?u,?d,?t2) ]));

        virtual-q'(?u) = max[0, virtual-q(?u) + src-overflow(?u) - src-flow(?u)];

        // Turning outflows
        Ml'(?u,?d,?o,?t) =
              (TIME-VAL(?t) == tau(?u,?d))     * (1-gamma(?u,?d)) * turn-outflow(?u,?d,?o)
            + (TIME-VAL(?t) == (tau(?u,?d)+1)) * gamma(?u,?d) * turn-outflow(?u,?d,?o)
            + (sum_{?t2 : time}[ NEXT(?t,?t2) * Ml(?u,?d,?o,?t2) ]);
            
        q'(?u,?d,?o) = [q(?u,?d,?o) + BETA(?u,?d,?o)*Ma(?u,?d) - turn-outflow(?u,?d,?o)] * TURN(?u,?d,?o);

        qd'(?u,?d) = (sum_{?o : intersection}[q(?u,?d,?o) * LINK(?d,?o)]) * LINK(?u,?d);

        Nc'(?u,?d) =
            Nc(?u,?d)
            + (sum_{?i : intersection} [turn-outflow(?i,?u,?d)])
            + src-flow(?u)
            - SINK(?d)*Ma(?u,?d)
            - (sum_{?o : intersection}[turn-outflow(?u,?d,?o)]);

        // Phases
        // Change action triggers an all-red phase.
        // During all-red, cur-ph-idx is equal to the index of the following phase,
        // and cur-ph-t is 0

        cur-ph-idx'(?d) = set-phase(?d);

        cur-ph-t'(?d) = if (set-phase(?d) == cur-ph-idx(?d))
                            then [cur-ph-t(?d) + (all-red(?d) == 0)] else 0;

        cur-ph-before-min'(?d) = [ (cur-ph-t(?d) + Ts) < (sum_{?p : phase} [PHASE-OF(?p,?d) * (PHASE-INDEX(?p)==cur-ph-idx(?d)) * PHASE-MIN(?p)]) ];

        cur-ph-at-max'(?d) = [ (cur-ph-t(?d) + Ts) >= (sum_{?p : phase} [PHASE-OF(?p,?d) * (PHASE-INDEX(?p)==cur-ph-idx(?d)) * PHASE-MAX(?p)]) ];

        all-red'(?d) = if (set-phase(?d) == cur-ph-idx(?d))
                           then max[all-red(?d) - Ts, 0]
                       else
                           (sum_{?p : phase} [PHASE-OF(?p,?d) * (PHASE-INDEX(?p)==cur-ph-idx(?d)) * PHASE-ALL-RED-DUR(?p)]);
    };

    // minus number of cars in the network
    // minus all virtual queues at source nodes
    reward = - (sum_{?u : intersection, ?d : intersection}[Nc(?u,?d)*LINK(?u,?d)])
             - (sum_{?u2 : intersection}[virtual-q(?u2)*SOURCE(?u2)]);

    state-invariants {
        ////////////////////////////////////////////////////////////////
        // Do assertions about non-fluents belong here?

        // unique intersection indices
        forall_{?u : intersection} (sum_{?d: intersection}[INTERSECTION-INDEX(?u) == INTERSECTION-INDEX(?d)]) <= 1;

        // phase constraints make sense
        forall_{?p : phase} [ 0 < PHASE-MIN(?p) ];
        forall_{?p : phase} [ PHASE-MIN(?p) <= PHASE-MAX(?p) ];
        forall_{?p : phase} [ 0 <= PHASE-ALL-RED-DUR(?p) ];
        ////////////////////////////////////////////////////////////////


        // cur. phase index within bounds
//        forall_{?d : intersection} [ TL(?d) => [0 <= cur-ph-idx(?d)] ];
//        forall_{?d : intersection} [ TL(?d) => [cur-ph-idx(?d) < (sum_{?p : phase} [PHASE-OF(?p,?d)])] ];

        // constraints on the cur. phase time are implied by adherence to the action-preconditions below

        // remaining interphase time does not go negative
//        forall_{?d : intersection} [ TL(?d) => [0 <= all-red(?d)] ];
    };

    action-preconditions {
//        forall_{?d : intersection} [10 <= set-phase(?d)];
  //      forall_{?d : intersection} [set-phase(?d) <= 20];

        // do not take up actions for non-signalized intersections, and
//        forall_{?d : intersection} [ (~TL(?d)) => (set-phase(?d) == -1) ];

        // ensure each traffic light receives an action each time-step
//        forall_{?d : intersection} [ TL(?d) => (set-phase(?d) >= 0) ];

        // min. time constraint
        // if cur. phase time < min. time, force extend action
//        forall_{?d : intersection} [ (TL(?d) ^ cur-ph-before-min(?d)) => (set-phase(?d) == cur-ph-idx(?d)) ];

        // max. time constraint
        // if cur. phase time == max. time, force change action
//        forall_{?d : intersection} [ (TL(?d) ^ cur-ph-at-max(?d)) => (~(set-phase(?d) == cur-ph-idx(?d))) ];

        // phase transition constraint
//        forall_{?d: intersection} [ (TL(?d) ^ (~(set-phase(?d) == cur-ph-idx(?d)))) => 
//            ([sum_{?p0 : phase} [sum_{?p1 : phase} [
//                PHASE-OF(?p0,?d) * PHASE-OF(?p1,?d) 
//                * (PHASE-INDEX(?p0)==cur-ph-idx(?d)) * (PHASE-INDEX(?p1)==set-phase(?d))
//                * VALID-CHANGE(?p0,?p1)
//            ]]] == 1) ];
    };

}


