///////////////////////////////////////////////////////////////////////////////
//
//  A BLX transportation model of macroscopic urban traffic network model
//
//  Author: Ayal Taitler (ataitler@gmail.com)
//
//  Reference:
//      S. Lin, B. De Schutter, Y. Xi, and J. Hellendoorn, "A simplified macroscopic urban
//      traffic network model for model-based predictive control," Proceedings of the 12th
//      IFAC Symposium on Transportation Systems, Redondo Beach, California, pp. 286â€“
//      291, Sept. 2009
//
///////////////////////////////////////////////////////////////////////////////

domain BLX_model {

    types {
        intersection : object;
    };

    pvariables {
        //////////////////////////////
        // non-fluents == topology
        //////////////////////////////
        // link between (uplink intersection, downlink intersection)
        LINK(intersection, intersection)     :  { non-fluent, bool, default = false };
        // number of lanes in link
        Nl(intersection, intersection)        : { non-fluent, int, default = 1 };
        // free-flow velocity of traffic in link in m/s
        V(intersection, intersection)        :  { non-fluent, real, default = 13.8 };
        // simulation time step in seconds
        Ts                                   :  { non-fluent, int, default = 1 };
        // average vehicle length im meters
        Lv                                   :  { non-fluent, real, default = 3 };
        // distance between intersections
        Dl(intersection, intersection)       :  { non-fluent, real, default = 100 };
        // saturated flow rate leaving link (u,d)
        MU(intersection, intersection)       :  { non-fluent, real, default = 1 };
        // fraction of the traffic turning to link (d,o) from link (u,d)
        BETA(intersection, intersection, intersection)     :  { non-fluent, real, default = 0.33 };
        // is intersection a source
        SOURCE(intersection)                 :  { non-fluent, bool, default = false};
        // is intersection a sink
        SINK(intersection)                   :  { non-fluent, bool, default = false};
        // arrival rate at sources - the variance for a uniform distribution
        ARRIVAL(intersection)                :  { non-fluent, int, default = 1};


        //////////////////////////////
        // interm fluents
        //////////////////////////////
        // link capacity
        Cl(intersection, intersection)                  :  { interm-fluent, real };
        //temp(intersection, intersection)                  :  { interm-fluent, real };

        // time delay constants
        tau(intersection, intersection)                 :  { interm-fluent, int };
        gama(intersection, intersection)                :  { interm-fluent, int };

        // time delayed queue of the the leaving traffic for k-tau
        Mltau(intersection, intersection, intersection) :  { interm-fluent, real };
        // time delayed queue of the the leaving traffic for k-tau-1
        Mltau1(intersection, intersection, intersection):  { interm-fluent, real };

        // number of cars arriving at the end of the queue (u,d)
        Ma(intersection, intersection)                  :  { interm-fluent, real };

        //arrivals at time step k in link (u,d) is u is a source
        arrivals(intersection)                          : { interm-fluent, real };


        //////////////////////////////
        // states fluents
        //////////////////////////////
        // number of cars leaving link (u,d) and turning towards link Om - state because of the time delay "memory"
        Ml(intersection, intersection, intersection) :  { state-fluent, real, default = 0 };
        // one time unit delay queue
        Ml1(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        // two time units delay queue
        Ml2(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml3(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml4(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml5(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml6(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml7(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml8(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml9(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml10(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml11(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml12(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml13(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml14(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml15(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml16(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml17(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml18(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml19(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml20(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml21(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml22(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml23(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml24(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml25(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml26(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml27(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml28(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml29(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml30(intersection, intersection, intersection): { state-fluent, real, default = 0 };
        Ml31(intersection, intersection, intersection): { state-fluent, real, default = 0 };


        // available storage space of link (u,d) in number of cars
        S(intersection, intersection)                :  { state-fluent, int, default = 100 };

        // queue length at step in link (u,d) turning in direction Om
        q(intersection, intersection, intersection)  :  { state-fluent, int, default = 0 };

        // total queue length at step in link (u,d) (all directions)
        qd(intersection, intersection)               :  { state-fluent, int, default = 0 };

        // number of vehicles in link
        Nc(intersection, intersection)               :  { state-fluent, real, default = 0 };


        //////////////////////////////
        // action fluents
        //////////////////////////////
        // is green for inflows from link (u,d) in the direction of link (d,o)
        b(intersection, intersection, intersection)  :  { action-fluent, bool, default = false };


        //////////////////////////////
        // observation fluents
        //////////////////////////////
        // only the queues that are relevant (no time delay queues, and no total of vehicle number)

    };

    cpfs {

        // derived fluent for the actual capacity
        Cl(?u,?d) = Dl(?u,?d) * Nl(?u,?d) / Lv;

        ////////////////////////////////////
        // interm fluents
        ////////////////////////////////////
        // derived fluent for the actual capacity
        Cl(?u,?d) = Dl(?u,?d) * Nl(?u,?d) / Lv;

        // time delay constants
        tau(?u,?d) = LINK(?u,?d) * floor[ (Cl(?u,?d) - qd(?u,?d))*Lv / (Nl(?u,?d)*V(?u,?d)*Ts) ] ;
        gama(?u,?d) = LINK(?u,?d) * mod[ (Cl(?u,?d) - qd(?u,?d))*Lv , (Nl(?u,?d)*V(?u,?d)*Ts) ];

        // time delay queue of k-tau(k)
        Mltau(?u,?d,?o) = if (tau(?u,?d) == 0) then Ml(?u,?d,?o)
                          else if (tau(?u,?d) == 1) then Ml1(?u,?d,?o)
                          else if (tau(?u,?d) == 2) then Ml2(?u,?d,?o)
                          else if (tau(?u,?d) == 3) then Ml3(?u,?d,?o)
                          else if (tau(?u,?d) == 4) then Ml4(?u,?d,?o)
                          else if (tau(?u,?d) == 5) then Ml5(?u,?d,?o)
                          else if (tau(?u,?d) == 6) then Ml6(?u,?d,?o)
                          else if (tau(?u,?d) == 7) then Ml7(?u,?d,?o)
                          else if (tau(?u,?d) == 8) then Ml8(?u,?d,?o)
                          else if (tau(?u,?d) == 9) then Ml9(?u,?d,?o)
                          else if (tau(?u,?d) == 10) then Ml10(?u,?d,?o)
                          else if (tau(?u,?d) == 11) then Ml11(?u,?d,?o)
                          else if (tau(?u,?d) == 12) then Ml12(?u,?d,?o)
                          else if (tau(?u,?d) == 13) then Ml13(?u,?d,?o)
                          else if (tau(?u,?d) == 14) then Ml14(?u,?d,?o)
                          else if (tau(?u,?d) == 15) then Ml15(?u,?d,?o)
                          else if (tau(?u,?d) == 16) then Ml16(?u,?d,?o)
                          else if (tau(?u,?d) == 17) then Ml17(?u,?d,?o)
                          else if (tau(?u,?d) == 18) then Ml18(?u,?d,?o)
                          else if (tau(?u,?d) == 19) then Ml19(?u,?d,?o)
                          else if (tau(?u,?d) == 20) then Ml20(?u,?d,?o)
                          else if (tau(?u,?d) == 21) then Ml21(?u,?d,?o)
                          else if (tau(?u,?d) == 22) then Ml22(?u,?d,?o)
                          else if (tau(?u,?d) == 23) then Ml23(?u,?d,?o)
                          else if (tau(?u,?d) == 24) then Ml24(?u,?d,?o)
                          else if (tau(?u,?d) == 25) then Ml25(?u,?d,?o)
                          else if (tau(?u,?d) == 26) then Ml26(?u,?d,?o)
                          else if (tau(?u,?d) == 27) then Ml27(?u,?d,?o)
                          else if (tau(?u,?d) == 28) then Ml28(?u,?d,?o)
                          else if (tau(?u,?d) == 29) then Ml29(?u,?d,?o)
                          else if (tau(?u,?d) == 30) then Ml30(?u,?d,?o)
                          else 0;

        // time delay queue of time k-tau(k)-1
        Mltau1(?u,?d,?o) = if (tau(?u,?d) == 0) then Ml1(?u,?d,?o)
                          else if (tau(?u,?d) == 1) then Ml2(?u,?d,?o)
                          else if (tau(?u,?d) == 2) then Ml3(?u,?d,?o)
                          else if (tau(?u,?d) == 3) then Ml4(?u,?d,?o)
                          else if (tau(?u,?d) == 4) then Ml5(?u,?d,?o)
                          else if (tau(?u,?d) == 5) then Ml6(?u,?d,?o)
                          else if (tau(?u,?d) == 6) then Ml7(?u,?d,?o)
                          else if (tau(?u,?d) == 7) then Ml8(?u,?d,?o)
                          else if (tau(?u,?d) == 8) then Ml9(?u,?d,?o)
                          else if (tau(?u,?d) == 9) then Ml10(?u,?d,?o)
                          else if (tau(?u,?d) == 10) then Ml11(?u,?d,?o)
                          else if (tau(?u,?d) == 11) then Ml12(?u,?d,?o)
                          else if (tau(?u,?d) == 12) then Ml13(?u,?d,?o)
                          else if (tau(?u,?d) == 13) then Ml14(?u,?d,?o)
                          else if (tau(?u,?d) == 14) then Ml15(?u,?d,?o)
                          else if (tau(?u,?d) == 15) then Ml16(?u,?d,?o)
                          else if (tau(?u,?d) == 16) then Ml17(?u,?d,?o)
                          else if (tau(?u,?d) == 17) then Ml18(?u,?d,?o)
                          else if (tau(?u,?d) == 18) then Ml19(?u,?d,?o)
                          else if (tau(?u,?d) == 19) then Ml20(?u,?d,?o)
                          else if (tau(?u,?d) == 20) then Ml21(?u,?d,?o)
                          else if (tau(?u,?d) == 21) then Ml22(?u,?d,?o)
                          else if (tau(?u,?d) == 22) then Ml23(?u,?d,?o)
                          else if (tau(?u,?d) == 23) then Ml24(?u,?d,?o)
                          else if (tau(?u,?d) == 24) then Ml25(?u,?d,?o)
                          else if (tau(?u,?d) == 25) then Ml26(?u,?d,?o)
                          else if (tau(?u,?d) == 26) then Ml27(?u,?d,?o)
                          else if (tau(?u,?d) == 27) then Ml28(?u,?d,?o)
                          else if (tau(?u,?d) == 28) then Ml29(?u,?d,?o)
                          else if (tau(?u,?d) == 29) then Ml30(?u,?d,?o)
                          else if (tau(?u,?d) == 30) then Ml31(?u,?d,?o)
                          else 0;

        // arriving queue at link (u,d)
        Ma(?u,?d) =
            LINK(?u,?d) * (1 - gama(?u,?d)) * (sum_{?i : intersection}[Mltau(?i,?u,?d)*LINK(?i,?u)])
            + LINK(?u,?d) * gama(?u,?d) * (sum_{?i : intersection}[Mltau1(?i,?u,?d)*LINK(?i,?u)]);

        // how many cars should arrive for the direction of u on the link (u,d) if u is a source
        arrivals(?u) =  Uniform(0,ARRIVAL(?u)) * 10;


        ////////////////////////////////////
        // State space evolution
        ////////////////////////////////////
        Ml31'(?u,?d,?o) = Ml30(?u,?d,?o);
        Ml30'(?u,?d,?o) = Ml29(?u,?d,?o);
        Ml29'(?u,?d,?o) = Ml28(?u,?d,?o);
        Ml28'(?u,?d,?o) = Ml27(?u,?d,?o);
        Ml27'(?u,?d,?o) = Ml26(?u,?d,?o);
        Ml26'(?u,?d,?o) = Ml25(?u,?d,?o);
        Ml25'(?u,?d,?o) = Ml24(?u,?d,?o);
        Ml24'(?u,?d,?o) = Ml23(?u,?d,?o);
        Ml23'(?u,?d,?o) = Ml22(?u,?d,?o);
        Ml22'(?u,?d,?o) = Ml21(?u,?d,?o);
        Ml21'(?u,?d,?o) = Ml20(?u,?d,?o);
        Ml20'(?u,?d,?o) = Ml19(?u,?d,?o);
        Ml19'(?u,?d,?o) = Ml18(?u,?d,?o);
        Ml18'(?u,?d,?o) = Ml17(?u,?d,?o);
        Ml17'(?u,?d,?o) = Ml16(?u,?d,?o);
        Ml16'(?u,?d,?o) = Ml15(?u,?d,?o);
        Ml15'(?u,?d,?o) = Ml14(?u,?d,?o);
        Ml14'(?u,?d,?o) = Ml13(?u,?d,?o);
        Ml13'(?u,?d,?o) = Ml12(?u,?d,?o);
        Ml12'(?u,?d,?o) = Ml11(?u,?d,?o);
        Ml11'(?u,?d,?o) = Ml10(?u,?d,?o);
        Ml10'(?u,?d,?o) = Ml9(?u,?d,?o);
        Ml9'(?u,?d,?o) = Ml8(?u,?d,?o);
        Ml8'(?u,?d,?o) = Ml7(?u,?d,?o);
        Ml7'(?u,?d,?o) = Ml6(?u,?d,?o);
        Ml6'(?u,?d,?o) = Ml5(?u,?d,?o);
        Ml5'(?u,?d,?o) = Ml4(?u,?d,?o);
        Ml4'(?u,?d,?o) = Ml3(?u,?d,?o);
        Ml3'(?u,?d,?o) = Ml2(?u,?d,?o);
        Ml2'(?u,?d,?o) = Ml1(?u,?d,?o);
        Ml1'(?u,?d,?o) = Ml(?u,?d,?o);
        Ml'(?u,?d,?o) = if (b(?u,?d,?o))
                       then max[ 0, min[ q(?u,?d,?o)+Ma(?u,?d)*BETA(?u,?d,?o), min[S(?d,?o), BETA(?u,?d,?o)*MU(?u,?d)*Ts]   ]]
                            *LINK(?u,?d)*LINK(?d,?o)
                       else 0;

        q'(?u,?d,?o) = [q(?u,?d,?o) + BETA(?u,?d,?o)*Ma(?u,?d) - Ml(?u,?d,?o) + SOURCE(?u)*arrivals(?u)] * LINK(?d,?o)*LINK(?u,?d);
        qd'(?u,?d) = (sum_{?o : intersection}[q(?u,?d,?o)* LINK(?d,?o)]) * LINK(?u,?d);

        S'(?u,?d) = [S(?u,?d)
                    - (sum_{?i : intersection}[ Ml(?i,?u,?d) * LINK(?i,?d) ])
                    + (sum_{?o : intersection}[ Ml(?u,?d,?o) * LINK(?d,?o) ])] * LINK(?u,?d);

        // n_{u,d}(k+1) = n_{u,d}(k) - m^l_{u,d}(k) + \sum_{entering turns (u',d')} m^l_{u',d'}(k)
        Nc'(?u,?d) = [Nc(?u,?d)
                     - (sum_{?o : intersection}[Ml(?u,?d,?o)*LINK(?d,?o)])
                     + (sum_{?i : intersection}[Ml(?i,?u,?d)*LINK(?i,?u)])] * LINK(?u,?d) * (1-SINK(?d));

    };

    // number of cars in the network
    reward = sum_{?u : intersection, ?d : intersection}[Nc(?u,?d)*LINK(?u,?d)];

    state-invariants {
        // no more than 4 neighbours outgoing
        forall_{?u : intersection} [(sum_{?d : intersection} [LINK(?u,?d)]) <= 4];
        // no more than 4 neighbours ingoing
        forall_{?d : intersection} [(sum_{?u : intersection} [LINK(?u,?d)]) <= 4];
        //
    };

    action-preconditions {
        // any preconditions? only bools and should allow for arbitrary phasing schemes
    };

}


