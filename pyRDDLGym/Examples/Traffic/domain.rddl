///////////////////////////////////////////////////////////////////////////////
//
//  A BLX transportation model of macroscopic urban traffic network model
//
//  Author: Ayal Taitler (ataitler@gmail.com)
//
//  Reference:
//      S. Lin, B. De Schutter, Y. Xi, and J. Hellendoorn, "A simplified macroscopic urban
//      traffic network model for model-based predictive control," Proceedings of the 12th
//      IFAC Symposium on Transportation Systems, Redondo Beach, California, pp. 286â€“
//      291, Sept. 2009
//
///////////////////////////////////////////////////////////////////////////////

domain BLX_model {

    types {
        intersection : object;
    };

    pvariables {
        //////////////////////////////
        // non-fluents == topology
        //////////////////////////////
        // link between (uplink intersection, downlink intersection)
        LINK(intersection, intersection)     :  { non-fluent, bool, default = false };
        // number of lanes in link
        Nl(intersection, intersection)        : { non-fluent, int, default = 1 };
        // free-flow velocity of traffic in link in m/s
        V(intersection, intersection)        :  { non-fluent, real, default = 13.8 };
        // simulation time step in seconds
        Ts                                   :  { non-fluent, int, default = 1 };
        // average vehicle length im meters
        Lv                                   :  { non-fluent, real, default = 3 };
        // distance between intersections
        Dl(intersection, intersection)       :  { non-fluent, real, default = 100 };
        // saturated flow rate leaving link (u,d)
        MU(intersection, intersection)       :  { non-fluent, real, default = 1 };
        // fraction of the traffic turning to link (d,o) from link (u,d)
        BETA(intersection, intersection, intersection)     :  { non-fluent, real, default = 0.33 };
        // is intersection a source
        SOURCE(intersection)                 :  { non-fluent, bool, default = false};
        // is intersection a sink
        SINK(intersection)                   :  { non-fluent, bool, default = false};
        // arrival rate at sources - the variance for a uniform distribution
        ARRIVAL(intersection)                :  { non-fluent, int, default = 1};


        //////////////////////////////
        // interm fluents
        //////////////////////////////
        // link capacity
        Cl(intersection, intersection)                  :  { interm-fluent, real };
        //temp(intersection, intersection)                  :  { interm-fluent, real };

        // time delay constants
        tau(intersection, intersection)                 :  { interm-fluent, int };
        gama(intersection, intersection)                :  { interm-fluent, int };

        // time delayed queue of the the leaving traffic for k-tau
        Mltau(intersection, intersection, intersection) :  { interm-fluent, real };
        // time delayed queue of the the leaving traffic for k-tau-1
        Mltau1(intersection, intersection, intersection):  { interm-fluent, real };

        // number of cars arriving at the end of the queue (u,d)
        Ma(intersection, intersection)                  :  { interm-fluent, real };

        //arrivals at time step k in link (u,d) is u is a source
        arrivals(intersection)                          : { interm-fluent, real };


        //////////////////////////////
        // states fluents
        //////////////////////////////
        // number of cars leaving link (u,d) and turning towards link Om - state because of the time delay "memory"
        Ml(intersection, intersection, intersection) :  { state-fluent, real, default = 0 };
        // one time unit delay queue
        Ml1(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        // two time units delay queue
        Ml2(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml3(intersection, intersection, intersection):  { state-fluent, real, default = 0 };
        Ml4(intersection, intersection, intersection):  { state-fluent, real, default = 0 };

        // available storage space of link (u,d) in number of cars
        S(intersection, intersection)                :  { state-fluent, int, default = 100 };

        // queue length at step in link (u,d) turning in direction Om
        q(intersection, intersection, intersection)  :  { state-fluent, int, default = 0 };

        // total queue length at step in link (u,d) (all directions)
        qd(intersection, intersection)               :  { state-fluent, int, default = 0 };

        // number of vehicles in link
        Nc(intersection, intersection)               :  { state-fluent, real, default = 0 };


        //////////////////////////////
        // action fluents
        //////////////////////////////
        // is green for inflows from link (u,d) in the direction of link (d,o)
        //b(intersection, intersection, turn)  :  { derived-fluent, bool, default = false };
        b(intersection, intersection, intersection)  :  { action-fluent, bool, default = false };

    };

    cpfs {

        // derived fluentd
        Cl(?u,?d) = Dl(?u,?d) * Nl(?u,?d) / Lv;

        ////////////////////////////////////
        // interm fluents
        ////////////////////////////////////
        //temp(?u,?d) = (Cl(?u,?d) - qd(?u,?d))*Lv / (Nl(?u,?d)*V(?u,?d)*Ts);

//        tau(?u,?d) = LINK(?u,?d) * floor[ temp(?u,?d) ] ;
        tau(?u,?d) = LINK(?u,?d) * floor[ (Cl(?u,?d) - qd(?u,?d))*Lv / (Nl(?u,?d)*V(?u,?d)*Ts) ] ;
        //gama(?u,?d) = LINK(?u,?d) * mod[ temp(?u,?d) ];
        gama(?u,?d) = LINK(?u,?d) * mod[ (Cl(?u,?d) - qd(?u,?d))*Lv , (Nl(?u,?d)*V(?u,?d)*Ts) ];

        Ma(?u,?d) =
            LINK(?u,?d) * (1 - gama(?u,?d)) * (sum_{?i : intersection}[Mltau(?i,?u,?d)*LINK(?i,?u)])
            + LINK(?u,?d) * gama(?u,?d) * (sum_{?i : intersection}[Mltau1(?i,?u,?d)*LINK(?i,?u)]);

        Mltau(?u,?d,?o) = if (tau(?u,?d) == 0) then Ml(?u,?d,?o)
                          else if (tau(?u,?d) == 1) then Ml1(?u,?d,?o)
                          else if (tau(?u,?d) == 2) then Ml2(?u,?d,?o)
                          else if (tau(?u,?d) == 3) then Ml3(?u,?d,?o)
                          else if (tau(?u,?d) == 4) then Ml4(?u,?d,?o)
                          else 0;

        Mltau1(?u,?d,?o) = if (tau(?u,?d) == 0) then Ml1(?u,?d,?o)
                          else if (tau(?u,?d) == 1) then Ml2(?u,?d,?o)
                          else if (tau(?u,?d) == 2) then Ml3(?u,?d,?o)
                          else if (tau(?u,?d) == 3) then Ml4(?u,?d,?o)
                          else 0;

//        Ma'(?u,?d) =
//            LINK(?u,?d) * (1 - gama(?u,?d)) * sum_{?i : intersection}[Mltau(?i,?u,?d)*LINK(?i,?u)]
//            + LINK(?u,?d) * gama(?u,?d) * sum_{?i : intersection}[Mltau1(?i,?u,?d)*LINK(?i,?u)];

          // For now assume no delay in queue transfer - add support for time delays
//        Ma'(?u,?d) =
//                    sum_{?i : intersection}[Ml(?i,?u,?d)*LINK(?i,?u)]*LINK(?u,?d);

        // how many cars should arrive for the direction of u on the link (u,d) if u is a source
        arrivals(?u) =  Uniform(0,ARRIVAL(?u)) * 10;


        ////////////////////////////////////
        // State space evolution
        ////////////////////////////////////
        Ml4'(?u,?d,?o) = Ml3(?u,?d,?o);
        Ml3'(?u,?d,?o) = Ml2(?u,?d,?o);
        Ml2'(?u,?d,?o) = Ml1(?u,?d,?o);
        Ml1'(?u,?d,?o) = Ml(?u,?d,?o);
        Ml'(?u,?d,?o) = if (b(?u,?d,?o))
                       then max[ 0, min[ q(?u,?d,?o)+Ma(?u,?d)*BETA(?u,?d,?o), min[S(?d,?o), BETA(?u,?d,?o)*MU(?u,?d)*Ts]   ]]
                            *LINK(?u,?d)*LINK(?d,?o)
                       else 0;

        q'(?u,?d,?o) = [q(?u,?d,?o) + BETA(?u,?d,?o)*Ma(?u,?d) - Ml(?u,?d,?o) + SOURCE(?u)*arrivals(?u)] * LINK(?d,?o)*LINK(?u,?d);
        qd'(?u,?d) = (sum_{?o : intersection}[q(?u,?d,?o)* LINK(?d,?o)]) * LINK(?u,?d);

        S'(?u,?d) = [S(?u,?d)
                    - (sum_{?i : intersection}[ Ml(?i,?u,?d) * LINK(?i,?d) ])
                    + (sum_{?o : intersection}[ Ml(?u,?d,?o) * LINK(?d,?o) ])] * LINK(?u,?d);

        // n_{u,d}(k+1) = n_{u,d}(k) - m^l_{u,d}(k) + \sum_{entering turns (u',d')} m^l_{u',d'}(k)
        Nc'(?u,?d) = [Nc(?u,?d)
                     - (sum_{?o : intersection}[Ml(?u,?d,?o)*LINK(?d,?o)])
                     + (sum_{?i : intersection}[Ml(?i,?u,?d)*LINK(?i,?u)])] * LINK(?u,?d) * (1-SINK(?d));

    };

    // number of cars in the network
    reward = sum_{?u : intersection, ?d : intersection}[Nc(?u,?d)*LINK(?u,?d)];

    state-invariants {
        // no more than 4 neighbours outgoing
        forall_{?u : intersection} [(sum_{?d : intersection} [LINK(?u,?d)]) <= 4];
        // no more than 4 neighbours ingoing
        forall_{?d : intersection} [(sum_{?u : intersection} [LINK(?u,?d)]) <= 4];
        //
    };

    action-preconditions {
        // any preconditions? only bools and should allow for arbitrary phasing schemes
    };

}


