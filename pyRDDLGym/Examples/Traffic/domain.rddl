///////////////////////////////////////////////////////////////////////////////
//
//  A BLX\QTM transportation model of macroscopic urban traffic network model
//
//  Author: Ayal Taitler (ataitler@gmail.com)
//
//  References:
//      S. Lin, B. De Schutter, Y. Xi, and J. Hellendoorn, "A simplified macroscopic urban
//      traffic network model for model-based predictive control," Proceedings of the 12th
//      IFAC Symposium on Transportation Systems, Redondo Beach, California, pp. 286â€“
//      291, Sept. 2009
//
//      Guilliard, I., Sanner, S., Trevizan, F. W., & Williams, B. C. "Nonhomogeneous
//      time mixed integer linear programming formulation for traffic signal control,"
//      Transportation Research Record, pp. 128-138 2595(1), 2016
//
///////////////////////////////////////////////////////////////////////////////

domain BLX_model {

    types {
        intersection : object;
//        phase : object;
        time : object;
    };

    pvariables {
        ////////////////////////////////////////
        // non-fluents == topology and geometry
        ////////////////////////////////////////

        // simulation time step in seconds
        Ts                                                 :  { non-fluent, int, default = 1 };
        // average vehicle length in meters
        Lv                                                 :  { non-fluent, real, default = 5 };

        // cartesian coordinates of the intersection
        X(intersection)                                    :  { non-fluent, real, default = 0 };
        Y(intersection)                                    :  { non-fluent, real, default = 0 };

        // link between (uplink intersection, downlink intersection)
        LINK(intersection, intersection)                   :  { non-fluent, bool, default = false };
        // number of lanes in link
        Nl(intersection, intersection)                     : { non-fluent, int, default = 1 };
        // free-flow velocity of traffic in link in m/s
        V(intersection, intersection)                      :  { non-fluent, real, default = 13.8 };
        // saturation flow rate leaving turn (u,d,o)
        MU(intersection, intersection, intersection)       :  { non-fluent, real, default = 0.6 };
        // fraction of the traffic turning to link (d,o) from link (u,d)
        BETA(intersection, intersection, intersection)     :  { non-fluent, real, default = 0.33 };

        // is intersection a source?
        SOURCE(intersection)                               :  { non-fluent, bool, default = false };
        // is intersection a sink?
        SINK(intersection)                                 :  { non-fluent, bool, default = false };
        // arrival rate at sources - the variance for a uniform distribution
        ARRIVAL-RATE(intersection)                         :  { non-fluent, real, default = 0.67 };
        // max. flow per lane - cap when releasing virtual queue and vehicles at sinks
        MAX-FLOWRATE(intersection)                         :  { non-fluent, real, default = 0.67 };

        // time ordering for time-delayed queues
        NEXT(time, time)                                   :  { non-fluent, bool, default = false };
        // is the time index first in the queue, i,e., no delay
        TIME-HEAD(time)                                    :  {non-fluent, bool, default = false };
        // is the time index last in the queue, i,e., maximum delay memory depth
        TIME-TAIL(time)                                    :  {non-fluent, bool, default = false };
        // time object to actual time delay index
        TIME-VAL(time)                                     :  { non-fluent, int, default = 1 };



        //////////////////////////////
        // interm fluents
        //////////////////////////////

        // distance between intersections
        Dl(intersection, intersection)                         :  { interm-fluent, real };

        // link capacity (maximal storage)
        Cl(intersection, intersection)                         :  { interm-fluent, real };

        // time delay variables
        tau(intersection, intersection)                        :  { interm-fluent, int };
        gamma(intersection, intersection)                      :  { interm-fluent, real };

        // number of cars arriving at the end of the queue (u,d)
        Ma(intersection, intersection)                         :  { interm-fluent, real };

        // arrivals at time step k in link (u,d) is u is a source
        arrivals(intersection)                                 : { interm-fluent, real };

        // flow from source u into the network
        src-flow(intersection)                               : { interm-fluent, real };

        // overflow from source u
        src-overflow(intersection)                             : { interm-fluent, real };

        //outflow at turn (u,d,o)
        turn-outflow(intersection, intersection, intersection) : { interm-fluent, real };


        //////////////////////////////
        // states fluents
        //////////////////////////////
        // number of cars leaving link (u,d) and turning towards link (d,o) - state because of the time delay "memory"
        Ml(intersection, intersection, intersection, time) :  { state-fluent, real, default = 0 };

        // number of cars leaving source u toward intersection d - state because of the time delay "memory"
        Mlsrc(intersection, intersection, time)            :  { state-fluent, real, default = 0 };

        // queue length at step in link (u,d) turning in direction (d,o)
        q(intersection, intersection, intersection)        :  { state-fluent, real, default = 0 };

        // total queue length at step in link (u,d) (all directions)
        qd(intersection, intersection)                     :  { state-fluent, real, default = 0 };

        //virtual queue at source (u) (i.e. vehicles held outside of the network)
        virtual-q(intersection)                            :  { state-fluent, real, default = 0 };

        // number of vehicles in link
        Nc(intersection, intersection)                     :  { state-fluent, real, default = 0 };


        //////////////////////////////
        // action fluents
        //////////////////////////////
        // is green for inflows from link (u,d) in the direction of link (d,o)
        b(intersection, intersection, intersection)  :  { action-fluent, bool, default = false };


        //////////////////////////////
        // observation fluents
        //////////////////////////////
        // only the queues that are relevant (no time delay queues, and no total of vehicle number)

    };

    cpfs {

        ////////////////////////////////////
        // interm fluents
        ////////////////////////////////////

        // distance between intersections
        Dl(?u,?d) = sqrt[ (X(?u)-X(?d))*(X(?u)-X(?d)) + (Y(?u)-Y(?d))*(Y(?u)-Y(?d)) ];

        // derived fluent for the actual capacity
        Cl(?u,?d) = Dl(?u,?d) * Nl(?u,?d) / Lv;

        // time-delay variables update
        tau(?u,?d) = LINK(?u,?d) * floor[ (Cl(?u,?d) - qd(?u,?d))*Lv / (Nl(?u,?d)*V(?u,?d)*Ts) ];
        gamma(?u,?d) = LINK(?u,?d) * ((Cl(?u,?d) - qd(?u,?d))*Lv / (Nl(?u,?d)*V(?u,?d)*Ts) - tau(?u,?d));

        // how many cars should arrive for the direction of u on the link (u,d) if u is a source
        arrivals(?u) =  SOURCE(?u) * Uniform(0,2*ARRIVAL-RATE(?u)*Ts);

        // flows from source u
        src-flow(?u) = SOURCE(?u) * max[0, min[ arrivals(?u), sum_{?d : intersection}[ LINK(?u,?d) * (Cl(?u,?d)-Nc(?u,?d)) ]]];
        src-overflow(?u) = SOURCE(?u) * max[0, arrivals(?u) - src-flow(?u)];

        // number of vehicles arriving to tail of queue at link (u,d)
        // add time-delayed outflows from the sources and
        // time-delayed outflows over all incoming turns
        Ma(?u,?d) = LINK(?u,?d) * (     SOURCE(?u)  * sum_{?t1 : time}[TIME-HEAD(?t1) * Mlsrc(?u,?d,?t1)]
                                   + (1-SOURCE(?u)) * sum_{?t2 : time}[TIME-HEAD(?t2) * sum_{?i : intersection}[Ml(?i,?u,?d,?t2)]]);

        // outflow at turn (u,d,o)
        // min(undersaturated, saturated, oversaturated)
        turn-outflow(?u,?d,?o) = LINK(?u,?d)*LINK(?d,?o) * b(?u,?d,?o) 
                                 * max[0, min[ q(?u,?d,?o) + Ma(?u,?d)*BETA(?u,?d,?o), // Undersaturated flow
                                          min[ BETA(?u,?d,?o)*MU(?u,?d,?o)*Ts,         // Saturated flow
                                               Cl(?d,?o)-Nc(?d,?o) ]]];                // Oversaturated flow (Capacity-Count=Storage)
             

        ////////////////////////////////////
        // State space evolution
        ////////////////////////////////////

        // Source outflows and virtual queues
        Mlsrc'(?u,?d,?t) = LINK(?u,?d) * (
              (TIME-VAL(?t) == tau(?u,?d))     * (1-gamma(?u,?d)) * src-flow(?u)
            + (TIME-VAL(?t) == (tau(?u,?d)+1)) * gamma(?u,?d) * src-flow(?u)
            + sum_{?t2 : time}[ NEXT(?t,?t2) * Mlsrc(?u,?d,?t2) ]);

        virtual-q'(?u) = max[0, virtual-q(?u) + src-overflow(?u) - src-flow(?u)];

        // Turning outflows
        Ml'(?u,?d,?o,?t) =
              (TIME-VAL(?t) == tau(?u,?d))     * (1-gamma(?u,?d)) * turn-outflow(?u,?d,?o)
            + (TIME-VAL(?t) == (tau(?u,?d)+1)) * gamma(?u,?d) * turn-outflow(?u,?d,?o)
            + sum_{?t2 : time}[ NEXT(?t,?t2) * Ml(?u,?d,?o,?t2) ];
            
        q'(?u,?d,?o) = [q(?u,?d,?o) + BETA(?u,?d,?o)*Ma(?u,?d) - turn-outflow(?u,?d,?o)] * LINK(?d,?o)*LINK(?u,?d);

        qd'(?u,?d) = (sum_{?o : intersection}[q(?u,?d,?o) * LINK(?d,?o)]) * LINK(?u,?d);

        Nc'(?u,?d) = 
            Nc(?u,?d)
          + sum_{?i : intersection}[turn-outflow(?i,?u,?d)]
          + src-flow(?u)
          - (sum_{?o : intersection}[turn-outflow(?u,?d,?o)]
             + SINK(?d)*Ma(?u,?d));
    };

    // minus number of cars in the network
    // minus all virtual queues at source nodes
    reward = -(  sum_{?u : intersection, ?d : intersection}[Nc(?u,?d)*LINK(?u,?d)]
               + sum_{?u2 : intersection}[virtual-q(?u2)*SOURCE(?u2)]);

    state-invariants {
        // no more than 4 neighbours outgoing
        forall_{?u : intersection} [(sum_{?d : intersection} [LINK(?u,?d)]) <= 4];
        // no more than 4 neighbours ingoing
        forall_{?d : intersection} [(sum_{?u : intersection} [LINK(?u,?d)]) <= 4];

        // 0 <= gamma < 1
        // forall_{?u : intersection, ?d : intersection} [ 0 <= gamma(?u,?d) ^ gamma(?u,?d) < 1 ];
    };

    action-preconditions {
        // any preconditions? only bools and should allow for arbitrary phasing schemes
    };

}


