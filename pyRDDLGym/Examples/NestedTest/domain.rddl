// //////////////////////////////////////////////////////////////////////
// A simple model to test nesting of fluents.
// //////////////////////////////////////////////////////////////////////
domain nestedtest {

    requirements = {
		reward-deterministic
    };

    types {
		enum_level : { @l1 , @l2 , @l3 };
    };

    pvariables {
		COST(enum_level) : { non-fluent , real , default = 1 };
		NEXT(enum_level) : { non-fluent , enum_level, default = @l1 };
		
        matrix(enum_level, enum_level) : { state-fluent , enum_level , default = @l1 };	
        vector(enum_level) : { state-fluent , enum_level , default = @l1 };	
		scalar : { state-fluent, enum_level , default = @l1 };
		biggest(enum_level) : { state-fluent , enum_level , default = @l1 };
		random(enum_level, enum_level) : { state-fluent , real , default = 0 };
		mean(enum_level, enum_level) :  { state-fluent, real, default = 1 };
		cov(enum_level, enum_level, enum_level) :  { state-fluent, real, default = 1 };
		
		a : { action-fluent , bool , default = false };
    };

    cpfs {
		
        matrix'(?p, ?q) = NEXT(matrix(?p, ?q));	
		vector'(?p) = matrix'(NEXT(?p), NEXT(?p));
		scalar' = NEXT(NEXT(NEXT(matrix'(NEXT(NEXT(NEXT(@l1))), NEXT(NEXT(NEXT(@l3)))))));
		biggest'(?p) = ( argmax_{?q : enum_level } [ COST(matrix'(?p, ?q)) ] );
		mean'(?p, ?q) = COST(?q);
		cov'(?p, ?q, ?r) = if (?p == ?r) then 1.0 else 0.0;
		random'(?p, ?q) = MultivariateNormal[?q](mean'(?p, _), cov'(_, ?p, _));
    };

    reward = ( sum_{?p : enum_level, ?q : enum_level} [ COST(matrix(?p, ?q)) ] );
	
}