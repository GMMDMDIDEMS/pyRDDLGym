// //////////////////////////////////////////////////////////////////////
// A simple DBN ( variables are not parameterized ) exhibiting use of
// bools , ints , reals , enumerated types , intermediate variables , and
// observation variables .
//
// Author : Scott Sanner ( ssanner [at] gmail .com )
// //////////////////////////////////////////////////////////////////////
domain propdbn {

    requirements = {
        reward-deterministic , // Reward is a deterministic function
        integer-valued , // Uses integer variables
        continuous , // Uses continuous variables
        multivalued , // Uses enumerated variables
        intermediate-nodes , // Uses intermediate nodes
        partially-observed // Uses observation nodes
    };

    // User - defined types
    types {
		param : object;  // an object type
        enum_level : { @low , @medium , @high }; // An enumerated type
		enum_level2 : { @low2, @medium2, @high2 }; // Another enumerated type
    };

    pvariables {
        p(param) : { state-fluent , bool , default = false };
		q(param) : { state-fluent , bool , default = false };
		r(param) : { state-fluent , bool , default = false };
		s(param) : { state-fluent, enum_level2, default = @medium2 };

		i1(param) : { interm-fluent , int , level = 1 };
		i2(param) : { interm-fluent , enum_level , level = 2 };
		i3(param) : { interm-fluent , enum_level, level = 3 };

		o1(param) : { observ-fluent , bool };
		o2(param) : { observ-fluent , real };

		a(param) : { action-fluent , bool , default = false };
    };

    cpfs {
	
        p'(?p) = if ( p(?p) ^ r(?p) ) then Bernoulli (.9) else Bernoulli (.3);

		q'(?p) = if ( q(?p) ^ r(?p) ) then Bernoulli (.9) 
					else if ( a(?p) ) then Bernoulli (.3) else Bernoulli (.8);
	
		r'(?p) = if ( ~q(?p) ) then KronDelta ( r(?p) ) else KronDelta ( r(?p) <=> q(?p) );

		s'(?p) = Discrete ( enum_level2 ,
			@low2 : if ( p'(?p) > 0.5 ) then 0.5 else 0.2 ,
			@medium2 : if ( p'(?p) > 0.5 ) then 0.2 else 0.5 ,
			@high2 : 0.3
		);
		
		i1(?p) = KronDelta ( p(?p) + q(?p) + r(?p) );
		
		i2(?p) = Discrete ( enum_level ,
			@low : if ( i1(?p) >= 2) then 0.5 else 0.2 ,
			@medium : if ( i1(?p) >= 2) then 0.2 else 0.5 ,
			@high : 0.3
		);
		
		i3(?p) = switch ( s(?p) ) {
			case @low2 : @low,
			case @medium2 : @medium,
			case @high2 : @high
		};
		
		o1(?p) = Bernoulli ( ( p'(?p) + q'(?p) + r'(?p) ) / 3.0 );
	
		o2(?p) = switch ( i2(?p) ) {
			case @low : i1(?p) + 1.0 + Normal (0.0 , i1(?p) * i1(?p) ) ,
			case @medium : i1(?p) + 2.0 + Normal (0.0 , i1(?p) * i1(?p) /2.0) ,
			default : i1(?p) + 3.0 + Normal (0.0 , i1(?p) * i1(?p) /4.0) 
		};
    };

    // A boolean functions as a 0/1 integer when a numerical value is needed
    reward = ( sum_{?p : param} [p(?p) + q(?p) - r(?p) + 5* ( i2(?p) == @high )] );

}