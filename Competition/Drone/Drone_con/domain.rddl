///////////////////////////////////////////////////////////////////////////////
//
// Drone RDDL domain
//
///////////////////////////////////////////////////////////////////////////////

domain kinematic_drones_con{

types {
    aircraft : object;
};

pvariables {

    CONTROLLABLE(aircraft) : { non-fluent, bool, default = false}; // which aircraft can be controlled
    GRAVITY : { non-fluent, real, default = 9.8};

    // Bounds on the position of the aircraft
    MIN_X : { non-fluent, real, default = -500.0};
    MAX_X : { non-fluent, real, default = 500.0};
    MIN_Y : { non-fluent, real, default = -500.0};
    MAX_Y : { non-fluent, real, default = 500.0};
    MIN_Z : { non-fluent, real, default = -500.0};
    MAX_Z : { non-fluent, real, default = 500.0};

    SCALE_FACTOR  : { non-fluent, real, default = 0.1 };          // time scale factor for dynamic equations
    RANDOM_WALK_COEFF : {non-fluent, real, default = 0.1 };       // variance constant for random walk of non controllable drones
    VEL_REG     : {non-fluent, real, default = 0.001};            // regularizatino factor when dividing by zero velocity

    // bounds on actions
    MIN_ACC(aircraft) : {non-fluent, real, default = -1.0};
    MAX_ACC(aircraft) : {non-fluent, real, default = 1.0};
    MIN_PHI(aircraft) : {non-fluent, real, default = -1.0};
    MAX_PHI(aircraft) : {non-fluent, real, default = 1.0};
    MIN_THETA(aircraft) : {non-fluent, real, default = -1.0};
    MAX_THETA(aircraft) : {non-fluent, real, default = 1.0};

    // goal position
    GOAL_X(aircraft) : {non-fluent, real, default = 100.0};
    GOAL_Y(aircraft) : {non-fluent, real, default = 100.0};
    GOAL_Z(aircraft) : {non-fluent, real, default = 100.0};

    // States
    // Cartesian Coordinates
    pos_x(aircraft) : { state-fluent, real, default = 0.0 }; // X axis coordinate
    pos_y(aircraft) : { state-fluent, real, default = 0.0 }; // Y axis coordinate
    pos_z(aircraft) : { state-fluent, real, default = 0.0 }; // Z axis coordinate
    // Angles
    theta(aircraft) : { state-fluent, real, default = 0.0 };  // pitch
    phi(aircraft) : { state-fluent, real, default = 0.0 };    // roll
    psi(aircraft) : { state-fluent, real, default = 0.0 };    // yaw
    // velocity
    vel(aircraft) : { state-fluent, real, default = 1.0 }; // velocity in the direction of the nose

    // actions
    set_acc(aircraft)  :  { action-fluent, real, default = 0.0 };
    set_phi(aircraft)  :  { action-fluent, real, default = 0.0 };
    set_theta(aircraft)  :  { action-fluent, real, default = 0.0 };
   
};

cpfs {

    // position changes for each time step
    pos_x'(?a) = if (CONTROLLABLE(?a))
                 then pos_x(?a) + SCALE_FACTOR * vel(?a) * cos[psi(?a)]
                 else pos_x(?a) + Normal(0.0, RANDOM_WALK_COEFF);
    pos_y'(?a) = if (CONTROLLABLE(?a))
                 then pos_y(?a) + SCALE_FACTOR * vel(?a) * sin[psi(?a)]
                 else pos_y(?a) + Normal(0.0, RANDOM_WALK_COEFF);
    pos_z'(?a) = if (CONTROLLABLE(?a))
                 then pos_z(?a) + SCALE_FACTOR * vel(?a) * sin[theta(?a)]
                 else pos_z(?a) + Normal(0.0, RANDOM_WALK_COEFF);

    // velocity
    vel'(?a) = if (CONTROLLABLE(?a))
               then vel(?a) + SCALE_FACTOR * max[min[set_acc(?a), MAX_ACC(?a)], MIN_ACC(?a)]
               else vel(?a) + Normal(0.0, RANDOM_WALK_COEFF);

    // angle changes
    phi'(?a) = if (CONTROLLABLE(?a))
               then phi(?a) + SCALE_FACTOR * max[min[set_phi(?a), MAX_PHI(?a)], MIN_PHI(?a)]
               else phi(?a) + Normal(0.0, RANDOM_WALK_COEFF);
    theta'(?a) = if (CONTROLLABLE(?a))
                 then theta(?a) + SCALE_FACTOR * max[min[set_theta(?a), MAX_THETA(?a)], MIN_THETA(?a)]
                 else theta(?a) + Normal(0.0, RANDOM_WALK_COEFF);
    psi'(?a) = if (CONTROLLABLE(?a))
               then psi(?a) + SCALE_FACTOR * (tan[phi(?a)] / (vel(?a)+VEL_REG)) * GRAVITY
               else psi(?a) + Normal(0.0, RANDOM_WALK_COEFF);

};

reward = -sum_{?a : aircraft} [CONTROLLABLE(?a) * [sqrt[pow[(pos_x(?a) - GOAL_X(?a)),2] +
                                   pow[(pos_y(?a) - GOAL_Y(?a)),2] +
                                   pow[(pos_z(?a) - GOAL_Z(?a)),2]]] ];

//reward = sum_{?a : aircraft} [ 1 / (sqrt[pow[(pos_x(?a) - GOAL_X(?a)),2] +
//                                   pow[(pos_y(?a) - GOAL_Y(?a)),2] +
//                                   pow[(pos_z(?a) - GOAL_Z(?a)),2]]) ];

state-invariants {
    // boundaries of the aircraft locations
    forall_{?a : aircraft}[ pos_x(?a) <= MAX_X ];
    forall_{?a : aircraft}[ pos_x(?a) >= MIN_X ];
    forall_{?a : aircraft}[ pos_y(?a) <= MAX_Y ];
    forall_{?a : aircraft}[ pos_y(?a) >= MIN_Y ];
    forall_{?a : aircraft}[ pos_z(?a) <= MAX_Z ];
    forall_{?a : aircraft}[ pos_z(?a) >= MIN_Z ];

    //forall_{?a : aircraft}[ pos_x(?a) <= MAX_X ^ pos_x(?a) >= MIN_X ^
    //                        pos_y(?a) <= MAX_Y ^ pos_y(?a) >= MIN_Y ^
    //                        pos_z(?a) <= MAX_Z ^ pos_x(?a) >= MIN_Z ];
    };

action-preconditions {
    // boundaries for set acc
    //forall_{?a : aircraft}[ set_acc(?a) <= MAX_ACC(?a)];
    forall_{?a : aircraft}[ set_acc(?a) >= MIN_ACC(?a)];
    forall_{?a : aircraft}[ set_phi(?a) <= MAX_PHI(?a)];
    forall_{?a : aircraft}[ set_phi(?a) >= MIN_PHI(?a)];
    forall_{?a : aircraft}[ set_theta(?a) <= MAX_THETA(?a)];
    forall_{?a : aircraft}[ set_theta(?a) >= MIN_THETA(?a)];
};

}