///////////////////////////////////////////////////////////////////////////////
//
// Drone RDDL domain
//
///////////////////////////////////////////////////////////////////////////////

domain simple_aircraft_with_roll_test{

types {
    aircraft : object;

};

pvariables {

    CONTROLLABLE(aircraft) : { non-fluent, bool, default = false}; // which aircraft can be controlled

    // Bounds on the position of the aircraft
    MIN_X : { non-fluent, real, default = -50000.0};
    MAX_X : { non-fluent, real, default = 50000.0};
    MIN_Y : { non-fluent, real, default = -50000.0};
    MAX_Y : { non-fluent, real, default = 50000.0};
    MIN_Z : { non-fluent, real, default = -50000.0};
    MAX_Z : { non-fluent, real, default = 50000.0};


    MIN_G_LOAD(aircraft) : { non-fluent, real, default = 1.0};
    MAX_G_LOAD(aircraft) : { non-fluent, real, default = 8.0};
    MAX_ROLL(aircraft) : { non-fluent, real, default = 1.57};
    MIN_ROLL(aircraft) : { non-fluent, real, default = -1.57};
    MAX_PITCH(aircraft) : { non-fluent, real, default = 1.22};
    MIN_PITCH(aircraft) : { non-fluent, real, default = -1.22};

    GRAVITY : { non-fluent, real, default = 9.8};


    // Speed bounds
    MIN_SPEED(aircraft) : { non-fluent, real, default = -1.75};
    MAX_SPEED(aircraft) : { non-fluent, real, default = 1.75};
    
    // Coordinates
    pos_x(aircraft) : { state-fluent, real, default = 0.0 };
    pos_y(aircraft) : { state-fluent, real, default = 0.0 }; 
    pos_z(aircraft) : { state-fluent, real, default = 0.0 };

    //Drone state
    g_load(aircraft) : { state-fluent, real, default = 0.0 };

    // velocity
    vel(aircraft) : { state-fluent, real, default = 0.0 };

    // Rates at which control variables change (per second)
    // radians / sec
    yaw_rate(aircraft) : { state-fluent, real, default = 0.0 };
    pitch_rate(aircraft) : { state-fluent, real, default = 0.012 };
    roll_rate(aircraft) : { state-fluent, real, default = 0.174};

    // Control variables
    psi(aircraft) : { state-fluent, real, default = 0.0 };    // yaw
    theta(aircraft) : { state-fluent, real, default = 0.0 };  // pitch
    phi(aircraft) : { state-fluent, real, default = 0.0 };    // roll
    phi_c(aircraft) : { state-fluent, real, default = 0.0 };  // target roll


    // meters / sec
    speed_rate(aircraft) : { state-fluent, real, default = 0.0 };

    // auxiliary variables to track control of
    speed_control_accelerating(aircraft) : { state-fluent, bool, default = false };
    speed_control_decelerating(aircraft) : { state-fluent, bool, default = false };
    speed_control_cruising(aircraft) : { state-fluent, bool, default = true };
    
    pitch_control_upwards(aircraft) : { state-fluent, bool, default = false };
    pitch_control_downwards(aircraft) : { state-fluent, bool, default = false };
    pitch_control_level(aircraft) : { state-fluent, bool, default = true };

    // goal position
    goal_x(aircraft) : {state-fluent, real, default = 100.0};
    goal_y(aircraft) : {state-fluent, real, default = 100.0};
    goal_z(aircraft) : {state-fluent, real, default = 100.0};

    // actions
    accelerate(aircraft) : {action-fluent, bool, default = false};
    decelerate(aircraft) : {action-fluent, bool, default = false};
    cruise(aircraft) : {action-fluent, bool, default = false};
    pull_lever(aircraft) : {action-fluent, bool, default = false};
    push_lever(aircraft) : {action-fluent, bool, default = false};
    neutral_lever(aircraft) : {action-fluent, bool, default = false};
    increase_g_load(aircraft) : {action-fluent, bool, default = false};
    decrease_g_load(aircraft) : {action-fluent, bool, default = false};
    reset_g_load(aircraft) : {action-fluent, bool, default = false};


};

cpfs {

    // position changes for each time step
    pos_x'(?a) = pos_x(?a) + vel(?a) * cos[psi(?a)];
    pos_y'(?a) = pos_y(?a) + vel(?a) * sin[psi(?a)];
    pos_z'(?a) = pos_z(?a) + vel(?a) + sin[theta(?a)];

    // position of the goal
    goal_x'(?a) = goal_x(?a);
    goal_y'(?a) = goal_y(?a);
    goal_z'(?a) = goal_z(?a);
 
    // velocity changes for each time step
    vel'(?a) = 
        if (speed_control_accelerating(?a) ^ (vel(?a) < MAX_SPEED(?a)) )
            then vel(?a) + speed_rate(?a)
        else if (speed_control_decelerating(?a) ^ (vel(?a) < MAX_SPEED(?a)) )
            then vel(?a) - speed_rate(?a)
        else vel(?a);

    // yaw changes when pitch upwards
    psi'(?a) = 
        if (pitch_control_upwards(?a))
            then psi(?a) + yaw_rate(?a)
        else psi(?a);
    
    // roll changes
    phi'(?a) = 
        if ( (phi_c(?a) > phi(?a)) ^ (phi(?a) < MAX_ROLL(?a)) )
            then phi(?a) + roll_rate(?a)
        else if ( (phi_c(?a) < phi(?a)) ^ (phi(?a) > MIN_ROLL(?a)))
            then phi(?a) - roll_rate(?a)
        else phi(?a);

    // pitch change when move upwards and downwards
    theta'(?a) = 
        if (pitch_control_upwards(?a) ^ (theta(?a) < MAX_PITCH(?a)) )
            then theta(?a) + pitch_rate(?a)
        else if (pitch_control_downwards(?a) ^ (theta(?a) > MIN_PITCH(?a)) )
            then theta(?a) - pitch_rate(?a)
        else theta(?a);

    // target control changes
    phi_c'(?a) = 
        if ( (g_load(?a) <= MAX_G_LOAD(?a)) ^ (phi_c(?a) < MAX_ROLL(?a)) ^ CONTROLLABLE(?a) ^ increase_g_load(?a))
            then acos[1.0 / (g_load(?a) + 0.1)]
        else if ( (g_load(?a) >= MIN_G_LOAD(?a)) ^ CONTROLLABLE(?a) ^ decrease_g_load(?a))
            then acos[1.0 / (g_load(?a) + 0.1)]
        else if (CONTROLLABLE(?a) ^ reset_g_load(?a))
            then 0.0
        else phi_c(?a);

    // g_load change
    g_load'(?a) = 
        if ( (g_load(?a) <= MAX_G_LOAD(?a)) ^ CONTROLLABLE(?a) ^ increase_g_load(?a))
            then g_load(?a) + 0.1
        else if ( (g_load(?a) >= MIN_G_LOAD(?a)) ^ CONTROLLABLE(?a) ^ decrease_g_load(?a))
            then g_load(?a) - 0.1
        else if (CONTROLLABLE(?a) ^ reset_g_load(?a))
            then 1.0
        else
            g_load(?a);

    // not sure if this is constant
    speed_rate'(?a) = speed_rate(?a);
    pitch_rate'(?a) = pitch_rate(?a);
    roll_rate'(?a) = roll_rate(?a);


    // yaw rate 
    yaw_rate'(?a) = 
        if (pitch_control_upwards(?a))
            then yaw_rate(?a) + (tan[phi(?a)] / vel(?a)) * GRAVITY
        else yaw_rate(?a);
    

    // Instantaneous actions
    speed_control_accelerating'(?a) = 
        if (CONTROLLABLE(?a) ^ accelerate(?a) ^ (vel(?a) < MAX_SPEED(?a)) )
            then true
        else if (CONTROLLABLE(?a) ^ cruise(?a))
            then false
        else speed_control_accelerating(?a);

    speed_control_decelerating'(?a) = 
        if (CONTROLLABLE(?a) ^ decelerate(?a) ^ (vel(?a) > MIN_SPEED(?a)) )
            then true
        else if (CONTROLLABLE(?a) ^ cruise(?a))
            then false
        else speed_control_decelerating(?a);

    speed_control_cruising'(?a) =
        if (CONTROLLABLE(?a) ^ cruise(?a))
            then true
        else if (CONTROLLABLE(?a) ^ (accelerate(?a) | decelerate(?a)))
            then false
        else speed_control_cruising(?a);

    pitch_control_upwards'(?a) = 
        if (CONTROLLABLE(?a) ^ pull_lever(?a))
            then true
        else if (CONTROLLABLE(?a) ^ neutral_lever(?a))
            then false
        else pitch_control_upwards(?a);

    pitch_control_downwards'(?a) = 
        if (CONTROLLABLE(?a) ^ push_lever(?a))
            then true
        else if (CONTROLLABLE(?a) ^ neutral_lever(?a))
            then false
        else pitch_control_downwards(?a);

    pitch_control_level'(?a) =
        if (CONTROLLABLE(?a) ^ neutral_lever(?a))
            then true
        else if (CONTROLLABLE(?a) ^ (pull_lever(?a) | push_lever(?a)))
            then false
        else pitch_control_level(?a);

};

state-invariants {
    // boundries of the aircarft locations
    // forall_{?a : aircraft}[ pos_x(?a) <= MAX_X ^ pos_x(?a) >= MIN_X ^
    //                         pos_y(?a) <= MAX_Y ^ pos_y(?a) >= MIN_Y ^
    //                         pos_z(?a) <= MAX_Z ^ pos_x(?a) >= MIN_Z ];
    

};

reward = sum_{?a : aircraft} [sqrt[pow[(pos_x(?a) - goal_x(?a)),2] + 
                                   pow[(pos_y(?a) - goal_y(?a)),2] +
                                   pow[(pos_z(?a) - goal_z(?a)),2]] ];

state-action-constraints {
    // Max of one action per aircraft.
	// forall_{?a : aircraft} [(increase_g_load(?a) + decrease_g_load(?a) + reset_g_load(?a) +
    //                         accelerate(?a) + decelerate(?a) + cruise(?a) + 
    //                        pull_lever(?a) + push_lever(?a) + neutral_lever(?a))  == 1];
    forall_{?a : aircraft} [(accelerate(?a) + decelerate(?a) + cruise(?a) +
                             pull_lever(?a) + push_lever(?a) + neutral_lever(?a) + 
                             increase_g_load(?a) + decrease_g_load(?a) + reset_g_load(?a)) <= 1];

    
    // Need to cruise before accelrate or decelerate
    forall_{?a : aircraft} [accelerate(?a) => speed_control_cruising(?a)];
    forall_{?a : aircraft} [decelerate(?a) => speed_control_cruising(?a)];
    forall_{?a : aircraft} [pull_lever(?a) => pitch_control_level(?a)];
    forall_{?a : aircraft} [push_lever(?a) => pitch_control_level(?a)];
    //forall_{?a : aircaft} ~[speed_control_decelerating(?a) ^ accelerate(?a)];

    forall_{?a : aircraft}[ pos_x(?a) <= MAX_X ^ pos_x(?a) >= MIN_X ^
                            pos_y(?a) <= MAX_Y ^ pos_y(?a) >= MIN_Y ^
                            pos_z(?a) <= MAX_Z ^ pos_x(?a) >= MIN_Z ];

};

}