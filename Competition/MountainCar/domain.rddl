////////////////////////////////////////////////////////////////////
// A simple continuous MDP for the classical mountain car control
// problem. A car is placed at the bottom of a valley, and must be
// brought to a destination located at the top of a hill by pushing
// the car left and right. 
////////////////////////////////////////////////////////////////////
domain mountain_car {

    requirements = {
        reward-deterministic
    };

    pvariables {

    	// physics constants
		GRAVITY_MAG : { non-fluent, real, default = 0.0025 };       // force of gravity acting down
		FORCE_MAG 	: { non-fluent, real, default = 0.001 };		// force applied to the side of the cart

		// valley shape
		DEPTH : { non-fluent, real, default = 0.45 };				// depth of the valley
		
		// bounds
		MIN_POS : { non-fluent, real, default = -1.2 };        		// min position of cart
		MAX_POS : { non-fluent, real, default = 0.6 };			 	// max position of cart
		MAX_VEL : { non-fluent, real, default = 0.07 };				// max velocity of cart
		GOAL_MIN : { non-fluent, real, default = 0.5 };				// desired x position of cart
		
		// interm & derived fluents
		success : { derived-fluent, bool };                       	// whether the cart reached its goal
				
		// states
       	pos    	: { state-fluent, real, default = -0.5 };          	// cart position
       	vel   	: { state-fluent, real, default = 0 };          	// cart velocity

       	// actions
       	action : { action-fluent, int, default = 1 };      			// whether to accelerate left (0), none (1) or right (2)
    };

    cpfs {
		// check if we reached the goal
		success = (pos >= GOAL_MIN) ^ (vel >= 0); 
		
		// update position and velocity of the cart
		vel' = if(success)
				then 0.0
				else [max[min[vel + (action - 1) * FORCE_MAG + cos[3 * pos] * (-GRAVITY_MAG) * (3 * DEPTH), 
						MAX_VEL], -MAX_VEL]];
		pos' = max[min[pos + vel', MAX_POS], MIN_POS];		
    };

    // R = 1 as long as the pole is upright and the cart is not out of bounds
    reward = if(success)
				then 1.0
				else 0.0;

    state-invariants {
		pos >= MIN_POS ^ pos <= MAX_POS;
		vel >= -MAX_VEL ^ vel <= MAX_VEL;
    };

    action-preconditions {
		(action == 0) | (action == 1) | (action == 2);
    };

}
