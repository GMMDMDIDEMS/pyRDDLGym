////////////////////////////////////////////////////////////////////
// A simple continuous MDP for multiagent mars rover science mission.  
//
// The goal here is to harvest as many high-value mineral (within their
// designated radii) as possible within the time constraints.
//
// The movement model is of a second order integrator in 2d
// The states for each drone is the x,y positions and velocities.
// The actions are acceleartion in the x,y axes.
// A third action for each drone is minearl harvesting when possible.
//
////////////////////////////////////////////////////////////////////
domain mars_rover_science_mission {

    requirements = {
        reward-deterministic
    };

    types {
		drone : object;
		mineral : object;
	}; 

    pvariables {

        // drone constants
        MAX_POWER(drone): { non-fluent, real, default = 0.05 };         // control norm constraint
        SCALE_FACTOR    : { non-fluent, real, default = 0.1 };          // time scale factor for dynamic equations

        // minerals constants
        MINERAL_AREA(mineral) : { non-fluent, real, default = 1 };            // mineral harvesting area
        MINERAL_VALUE(mineral): { non-fluent, real, default = 1 };            // mineral harvesting value
        MINERAL_POS_X(mineral): { non-fluent, real, default = 0 };            // mineral x location
        MINERAL_POS_Y(mineral): { non-fluent, real, default = 0 };            // mineral y location

        // interm & derived fluents
        power(drone) : { derived-fluent, real };                          // derived fluent for control input norm calculation
        u_x(drone) : { derived-fluent, real };                          // derived fluent for norm saturated x control
        u_y(drone) : { derived-fluent, real };                          // derived fluent for norm saturated y control

        // states
        vel_x(drone)    : { state-fluent, real, default = 0 };          // drone x direction velocity
        pos_x(drone)    : { state-fluent, real, default = 0 };          // drone x position
        vel_y(drone)    : { state-fluent, real, default = 0 };          // drone y velocity
        pos_y(drone)    : { state-fluent, real, default = 0 };          // drone y position
        mineral_harvested(mineral) : { state-fluent, bool, default = false }; // if a mineral has been mineral mineral harvested or not

        // actions
        power_x(drone)      : { action-fluent, real, default = 0 };     // force input in x direction
        power_y(drone)      : { action-fluent, real, default = 0 };     // force input in y direction
        harvest(drone)      : { action-fluent, bool, default = false }; // mineral harvesting action
    };

    cpfs {

        power(?d) = sqrt[ pow[power_x(?d), 2] + pow[power_y(?d), 2]];

        u_x(?d) = if(power(?d) >= MAX_POWER(?d))
                    then MAX_POWER(?d) * power_x(?d) / power(?d)
                    else power_x(?d);
        u_y(?d) = if(power(?d) >= MAX_POWER(?d))
                	then MAX_POWER(?d) * power_y(?d) / power(?d)
                	else power_y(?d);

        vel_x'(?d) = vel_x(?d) + SCALE_FACTOR * u_x(?d);
        vel_y'(?d) = vel_y(?d) + SCALE_FACTOR * u_y(?d);
        pos_x'(?d) = pos_x(?d) + SCALE_FACTOR * vel_x(?d);
        pos_y'(?d) = pos_y(?d) + SCALE_FACTOR * vel_y(?d);

        mineral_harvested'(?m) = mineral_harvested(?m) |
                ~mineral_harvested(?m) ^ [exists_{?d : drone}
                    [sqrt [ pow[pos_x(?d)-MINERAL_POS_X(?m),2] + pow[pos_y(?d)-MINERAL_POS_Y(?m),2]] < MINERAL_AREA(?m) ^ harvest(?d)]];

    };

    // R = -sum u_x^2 + u_y^2 + sum minerals harvested - sum harvested minerals
    reward = [-sum_{?d : drone} [ pow[u_x(?d), 2] + pow[u_y(?d), 2]]] +
             [sum_{?m : mineral }[if (exists_{?d : drone}
                        [(sqrt[pow[pos_x(?d)-MINERAL_POS_X(?m),2] + pow[pos_y(?d)-MINERAL_POS_Y(?m),2]] < MINERAL_AREA(?m)) ^ harvest(?d)])
                            then MINERAL_VALUE(?m)
                            else 0.0]]
             - [sum_{?d : drone} [harvest(?d)]];

    state-invariants {
        forall_{?m : mineral} [MINERAL_AREA(?m) > 0 ];
    };

    action-preconditions {
        forall_{?d : drone} [ power_x(?d) >= -MAX_POWER(?d) ];
        forall_{?d : drone} [ power_x(?d) <= MAX_POWER(?d) ];
        forall_{?d : drone} [ power_y(?d) >= -MAX_POWER(?d) ];
        forall_{?d : drone} [ power_y(?d) <= MAX_POWER(?d) ];
    };

}
