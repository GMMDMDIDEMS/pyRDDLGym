///////////////////////////////////////////////////////////////////////////////
//
// Drone RDDL domain
//
///////////////////////////////////////////////////////////////////////////////

domain simple_drone{

types {
    aircraft : object;

};

pvariables {

    CONTROLLABLE(aircraft) : { non-fluent, bool, default = false}; // which aircraft can be controlled

    // Bounds on the position of the aircraft
    MIN_X : { non-fluent, real, default = -50000.0};
    MAX_X : { non-fluent, real, default = 50000.0};
    MIN_Y : { non-fluent, real, default = -50000.0};
    MAX_Y : { non-fluent, real, default = 50000.0};
    MIN_Z : { non-fluent, real, default = -50000.0};
    MAX_Z : { non-fluent, real, default = 50000.0};

    GRAVITY : { non-fluent, real, default = 9.8};

    SCALE_FACTOR  : { non-fluent, real, default = 0.1 };          // time scale factor for dynamic equations

    // bounds for Rates
    INC_VEL(aircraft) : {non-fluent, real, default = 1.0};
    DEC_VEL(aircraft) : {non-fluent, real, default = -1.0};
    INC_PHI(aircraft) : {non-fluent, real, default = 1.0};
    DEC_PHI(aircraft) : {non-fluent, real, default = -1.0};
    INC_THETA(aircraft) : {non-fluent, real, default = 1.0};
    DEC_THETA(aircraft) : {non-fluent, real, default = -1.0};

    // goal position
    GOAL_X(aircraft) : {non-fluent, real, default = 100.0};
    GOAL_Y(aircraft) : {non-fluent, real, default = 100.0};
    GOAL_Z(aircraft) : {non-fluent, real, default = 100.0};
    
    // Coordinates
    pos_x(aircraft) : { state-fluent, real, default = 0.0 };
    pos_y(aircraft) : { state-fluent, real, default = 0.0 }; 
    pos_z(aircraft) : { state-fluent, real, default = 0.0 };

    // velocity
    vel(aircraft) : { state-fluent, real, default = 1.0 };

    // Control variables
    theta(aircraft) : { state-fluent, real, default = 0.0 };  // pitch
    phi(aircraft) : { state-fluent, real, default = 0.0 };    // roll
    psi(aircraft) : { state-fluent, real, default = 0.0 };    // yaw

    // actions
    // set_vel(aircraft)  :  { action-fluent, real, default = 0.0 };
    // set_phi(aircraft)  :  { action-fluent, real, default = 0.0 };
    // set_theta(aircraft)  :  { action-fluent, real, default = 0.0 };

    increase_vel(aircraft) : { action-fluent,  bool, default = false};
    decrease_vel(aircraft) : { action-fluent,  bool, default = false};
    increase_phi(aircraft) : { action-fluent,  bool, default = false};
    decrease_phi(aircraft) : { action-fluent,  bool, default = false};
    increase_theta(aircraft) : { action-fluent,  bool, default = false};
    decrease_theta(aircraft) : { action-fluent,  bool, default = false};
   
};

cpfs {

    // position changes for each time step
    pos_x'(?a) = pos_x(?a) + SCALE_FACTOR * vel(?a) * cos[psi(?a)];
    pos_y'(?a) = pos_y(?a) + SCALE_FACTOR * vel(?a) * sin[psi(?a)];
    pos_z'(?a) = pos_z(?a) + SCALE_FACTOR * vel(?a) * sin[theta(?a)];

    // velocity
    vel'(?a) = 
        if (increase_vel(?a))
            then vel(?a) + SCALE_FACTOR * INC_VEL(?a)
        else if (decrease_vel(?a))
            then vel(?a) + SCALE_FACTOR * DEC_VEL(?a)
        else vel(?a);

    // angle changes
    phi'(?a) = 
        if (increase_phi(?a))
            then phi(?a) + SCALE_FACTOR * INC_PHI(?a)
        else if (decrease_vel(?a))
            then phi(?a) + SCALE_FACTOR * DEC_PHI(?a)
        else phi(?a);

     theta'(?a) = 
        if (increase_theta(?a))
            then theta(?a) + SCALE_FACTOR * INC_THETA(?a)
        else if (decrease_theta(?a))
            then theta(?a) + SCALE_FACTOR * DEC_THETA(?a)
        else theta(?a);

    psi'(?a) = psi(?a) + SCALE_FACTOR * (tan[phi(?a)] / vel(?a)) * GRAVITY;

};

reward = sum_{?a : aircraft} [ 1 / (sqrt[pow[(pos_x(?a) - GOAL_X(?a)),2] + 
                                   pow[(pos_y(?a) - GOAL_Y(?a)),2] +
                                   pow[(pos_z(?a) - GOAL_Z(?a)),2]]) ];

action-preconditions {
    // boundries of the aircarft locations
    forall_{?a : aircraft}[ pos_x(?a) <= MAX_X ^ pos_x(?a) >= MIN_X ^
                            pos_y(?a) <= MAX_Y ^ pos_y(?a) >= MIN_Y ^
                            pos_z(?a) <= MAX_Z ^ pos_x(?a) >= MIN_Z ];

    forall_{?a : aircraft} [(increase_vel(?a) +  decrease_vel(?a)) <= 1];
    forall_{?a : aircraft} [(increase_phi(?a) +  decrease_phi(?a)) <= 1];
    forall_{?a : aircraft} [(increase_theta(?a) +  decrease_theta(?a)) <= 1];

};

}